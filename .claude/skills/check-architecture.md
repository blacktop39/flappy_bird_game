---
name: check-architecture
description: 코드가 설계 원칙을 잘 따르고 있는지 검증합니다
arguments:
  - name: file_path
    description: 검증할 파일 경로 (선택사항, 없으면 전체 프로젝트)
    required: false
---

# 아키텍처 설계 원칙 검증

다음 설계 원칙들을 체크하세요:

## 1. 관심사 분리 (Separation of Concerns)

{{#if file_path}}
{{file_path}} 파일을 분석하여:
{{else}}
lib/ 디렉토리 전체를 분석하여:
{{/if}}

- 모델(Model): 비즈니스 로직과 데이터만 포함하는가?
- 뷰(View/Widget): UI 렌더링만 담당하는가?
- 컨트롤러(Provider): 상태 관리와 로직만 처리하는가?

**문제 발견 시:**
- UI 로직이 모델에 있으면 → widgets로 분리
- 비즈니스 로직이 위젯에 있으면 → models 또는 providers로 분리
- 상태 관리가 뷰에 있으면 → providers로 분리

## 2. 단일 책임 원칙 (Single Responsibility)

각 클래스/함수가 하나의 책임만 가지는지 확인:

- 클래스가 너무 크지 않은가? (200줄 이상이면 경고)
- 함수가 너무 길지 않은가? (50줄 이상이면 경고)
- 클래스 이름이 "And", "Or", "Manager" 같은 모호한 단어를 포함하는가?

**문제 발견 시:**
- 큰 클래스는 여러 클래스로 분리
- 긴 함수는 작은 함수들로 분해
- 모호한 이름은 명확한 책임을 나타내는 이름으로 변경

## 3. 의존성 역전 (Dependency Inversion)

의존성이 올바르게 관리되는지 확인:

- 구체적인 구현이 아닌 추상화에 의존하는가?
- Riverpod Provider를 통한 의존성 주입을 사용하는가?
- 하드코딩된 의존성이 있는가?

**문제 발견 시:**
- 직접 인스턴스 생성(`new ClassName()`) → Provider로 주입
- 하드코딩된 값 → 상수 파일로 이동
- Singleton 패턴 남용 → Provider로 대체

## 4. DRY (Don't Repeat Yourself)

중복 코드가 있는지 확인:

- 동일하거나 유사한 코드가 3번 이상 반복되는가?
- 비슷한 로직을 가진 함수들이 여러 곳에 있는가?

**문제 발견 시:**
- 공통 함수로 추출
- 공통 위젯으로 분리
- 유틸리티 클래스 생성

## 5. 성능 최적화

Flutter 특화 최적화가 적용되었는지 확인:

- `const` 생성자를 사용할 수 있는 곳에 사용했는가?
- `RepaintBoundary`로 위젯 격리가 필요한가?
- `CustomPainter`를 사용할 수 있는 복잡한 그래픽이 있는가?
- 불필요한 `setState()` 호출이 있는가?

## 검증 결과 리포트 형식

검증 완료 후 다음 형식으로 리포트를 제공하세요:

```
## 🏗️ 아키텍처 검증 결과

### ✅ 잘 지켜진 원칙
- [원칙 이름]: [이유]

### ⚠️ 개선이 필요한 부분
- [파일:라인]: [문제점] → [해결 방안]

### 💡 제안사항
- [구체적인 개선 제안]

### 📊 코드 품질 점수: X/100
```

## 우선순위

1. **긴급**: 아키텍처 원칙을 심각하게 위반 (예: 모든 로직이 UI에 있음)
2. **높음**: 유지보수를 어렵게 만드는 문제 (예: 큰 클래스, 중복 코드)
3. **보통**: 개선하면 좋은 부분 (예: const 생성자 누락)
4. **낮음**: 선택적 최적화 (예: 미세한 성능 개선)
